<!doctype html><html lang=en><head><title>The Making of Project Haikuza: Part 2</title>
<meta property="og:image" content="https://justinmklam.com//posts/2015/making-haikuza-ii/VL01D336R8_hu_5296c9970c7b774e.jpg"><meta property="og:type" content="blog"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="When the generator gets a bit smarter, but still not smart enough."><meta name=author content="Justin Lam"><link rel=stylesheet href=/css/syntax.css media=screen><link rel=stylesheet href=/css/syntax-dark.css media="screen and (prefers-color-scheme: dark)"><link rel=stylesheet href=/css/neat.css><link rel=stylesheet href=/css/custom.css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-85178257-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-85178257-1")</script></head><body><div class="navbar row"><div><span class=navbar-brand>Justin Lam</span></div><div class=navbar-links><a href=/>Blog</a>
<a href=/archives/>Archives</a>
<a href=/about/>About</a>
<a href=/contact/>Contact</a></div></div><div><div class=single-content><h2 data-toc-skip class=blog-title>The Making of Project Haikuza: Part 2</h2><p class=blog-title-metadata>Posted on August 6, 2015
&nbsp;&#183;&nbsp;6 min read
&nbsp;&#183;&nbsp;
<span class=disqus-comment-count data-disqus-url=https://justinmklam.com/posts/2015/making-haikuza-ii/#disqus_thread>0 comments</span>
&nbsp;&#183;&nbsp;
<a class=blog-tag href=/tags/programming>#programming&nbsp;</a></p><a href=/posts/2015/making-haikuza-ii/VL01D336R8_hu_5296c9970c7b774e.jpg><img class="img-content img-content-header" src=/posts/2015/making-haikuza-ii/VL01D336R8_hu_5296c9970c7b774e.jpg></a><br><details class=toc><summary>&nbsp;Table of Contents</summary><nav id=TableOfContents><ul><li><a href=#the-lesser-known-cousin-of-2-chainz>The Lesser Known Cousin of 2 Chainz</a><ul><li><a href=#a-primer-for-markov-chains>A Primer for Markov Chains</a></li><li><a href=#harnessing-its-raw-indisputable-power>Harnessing its Raw, Indisputable Power</a></li><li><a href=#teaching-markov-the-art-of-haikus>Teaching Markov the Art of Haikus</a></li></ul></li></ul></nav></summary></details><div class="blog-content page-content"><p><em>The format of this series is an outline of my thought process during the development of <a href=/projects/software/haikuza/>@thehaikuza</a>.</em></p><blockquote style=text-align:center>Poetry is hard<br>To write when algorithms<br>Are extremely dumb.</blockquote><p>I dont want my haiku generator to be a vegetarian chef. There&rsquo;s nothing wrong with always making word salad, but eventually it&rsquo;ll have to learn to make fancier things. A poetic risotto would be nice from time to time.</p><p>Leaving @thehaikuza to make complete gibberish wasnt what I had intended. I envisioned my algorithm to be able to reconstruct bad haikus, but definitely not as crappy as the ones it actually made. My idea of bad had more to do with this xkcd comic:</p><p><div class="row captioned-img"><a href=/posts/2015/making-haikuza-ii/ios_keyboard.png><img loading=lazy class="img-responsive img-content" src=/posts/2015/making-haikuza-ii/ios_keyboard.png></a><p class=caption>iOS Keyboard Predictions (Source: xkcd.com/1427)</p></div></p><p>In any event, I needed to try something a little more sophisticated than shoving words into slots where they didn&rsquo;t really fit.</p><h1 id=the-lesser-known-cousin-of-2-chainz>The Lesser Known Cousin of 2 Chainz</h1><p>Every time I Googled a new topic I didnt know about, five more topics were thrown on my plate. Notable keywords that popped up:</p><ul><li>Computational linguistics</li><li>Neural networks</li><li>Sentiment classification</li><li>Bayesian inference</li><li>Tree kernels for semantic role labeling</li><li>Markov chains</li></ul><p>By no means am I suggesting that I understood all of those search terms after reading about them. In fact, I still don&rsquo;t and am constantly trying to wrap my head around those polysyllabic words. (Fun fact: anything above three syllables starts to scare most people.) The takeaway is the last item on the list, which coincidentally is the one I did manage to (somewhat) understand: the Markov chain.</p><h2 id=a-primer-for-markov-chains>A Primer for Markov Chains</h2><p>In technical terms, a Markov chain is any random process that undergoes transitions from one state to another. It&rsquo;s also a memoryless process, meaning that it only cares about its current state and not the states it has previously occupied.</p><p>In less technical terms, a Markov chain is like your tokens position during a game of Monopoly. The next property that your token lands on is random (ie. its a random state transition), and every dice roll is independent of the previous roll (ie. its a memoryless process). Probability determines what the next dice roll is: theres a higher chance of rolling a 7 since there are 6 possible combinations (6/36 = 16.7% probability), whereas theres only one way to roll a 2 or 12 (1/36 = 2.8% probability).</p><p>The marvelous aspect of Markov chains is that they can work with any item, not just numbers! Lets say you wanted to form sentences using Markov chains. Given a corpus of phrases (like the entire works of Shakespeare), a flowchart like the one below can be formed and used to create new phrases. Interestingly enough, this is the basis of prediction engines used on smartphone keyboards! It will learn from your phrasing habits and try to guess what your next word will be, based on how frequently youve typed similar words or phrases (just like the above xkcd comic).</p><p><div class="row captioned-img"><a href=/posts/2015/making-haikuza-ii/chain.png><img loading=lazy class="img-responsive img-content" src=/posts/2015/making-haikuza-ii/chain.png></a><p class=caption>Visualization of words forming a Markov chain. (Source: Andrew Cholakian&rsquo;s Blog)</p></div></p><h2 id=harnessing-its-raw-indisputable-power>Harnessing its Raw, Indisputable Power</h2><p>Using Markov chains would allow me to use song lyrics as a training ground for creating alternate phrases. This would consequently form a probability-based flowchart like the one above, allowing me to generate new sentences by walking through each word state and letting probability determine my next word.</p><p>To understand how to turn this into a programmable scenario, let&rsquo;s take a look at an example. Given a phrase like:</p><blockquote><p>Mo butter, mo better, mo slipperier</p></blockquote><p>A Markov chain algorithm will take triplets of the phrase, use the first two words as the dictionary word, and the third word as the definition. If you&rsquo;re familiar with using dictionaries in Python, the former is known as keys and the latter as values. This would result in the above phrase being translated to:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(&#39;mo&#39;, &#39;butter&#39;) : [&#39;mo&#39;]
</span></span><span class=line><span class=cl>(&#39;butter&#39;, &#39;mo&#39;) : [&#39;better&#39;]
</span></span><span class=line><span class=cl>(&#39;mo&#39;, &#39;better&#39;) : [&#39;mo&#39;]
</span></span><span class=line><span class=cl>(&#39;better&#39;, &#39;mo&#39;) : [&#39;slipperier&#39;]
</span></span></code></pre></div><p>Okay, but this isn&rsquo;t very captivating because there&rsquo;s a 1:1 ratio of keys to values, which means that there will never be any mixing and matching of words since the probability of the next word is always 1. Alternatively, if we have a sentence such as:</p><blockquote><p>Living in a land of butter is like living in a paradise with flying unicorns</p></blockquote><p>Then the resulting dictionary will look like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(&#39;Living&#39;, &#39;in&#39;) :     [&#39;a&#39;]
</span></span><span class=line><span class=cl>(&#39;in&#39;, &#39;a&#39;) :          [&#39;land&#39;, &#39;paradise&#39;]
</span></span><span class=line><span class=cl>(&#39;a&#39;, &#39;land&#39;) :        [&#39;of&#39;]
</span></span><span class=line><span class=cl>(&#39;land&#39;, &#39;of&#39;) :       [&#39;butter&#39;]
</span></span><span class=line><span class=cl>(&#39;of&#39;, &#39;butter&#39;) :     [&#39;is&#39;]
</span></span><span class=line><span class=cl>(&#39;butter&#39;, &#39;is&#39;) :     [&#39;like&#39;]
</span></span><span class=line><span class=cl>(&#39;is&#39;, &#39;like&#39;) :       [&#39;living&#39;]
</span></span><span class=line><span class=cl>(&#39;like&#39;, &#39;living&#39;) :   [&#39;in&#39;]
</span></span><span class=line><span class=cl>(&#39;living&#39;, &#39;in&#39;) :     [&#39;a&#39;]
</span></span><span class=line><span class=cl>(&#39;a&#39;, &#39;paradise&#39;) :    [&#39;with&#39;]
</span></span><span class=line><span class=cl>(&#39;paradise&#39;, &#39;with&#39;) : [&#39;flying&#39;]
</span></span><span class=line><span class=cl>(&#39;with&#39;, &#39;flying&#39;) :   [&#39;unicorns&#39;]
</span></span></code></pre></div><p>The interesting part of this phrase (other than the wildly imaginative scenario) is the second line item, where the key <em>(in, a)</em> has two possible values, either land or paradise. So if I&rsquo;m wandering around a word-based flowchart and come across the pair of words in a, my next word can either be land or paradise. Now, this was just for a 15 word phrase, so imagine the magnitude of choices if lyrics for an entire song was used (where more repetitions are prevalent), or all lyrics from an artists full discography, or even a body of text with a +1,000,000 word count meant for this purpose! More phrases and more words result in more possible combinations, which is excellent news for attempting to create pseudo-random sentences.</p><p>The code below for the Markov chain algorithm was adapted from Agiliqs Blog:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Markov</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>string</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cache</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>words</span> <span class=o>=</span> <span class=n>string</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>word_size</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>database</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nb>print</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>triples</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34; Generates triples from the given data string.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>)</span> <span class=o>==</span> <span class=mi>3</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>yield</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>database</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w1</span><span class=p>,</span> <span class=n>w2</span><span class=p>,</span> <span class=n>w3</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>triples</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>key</span> <span class=o>=</span> <span class=p>(</span><span class=n>w1</span><span class=p>,</span> <span class=n>w2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>key</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>key</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>w3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>w3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>generate_markov_text</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=mi>25</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>seed</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>word_size</span><span class=o>-</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>seed_word</span><span class=p>,</span> <span class=n>next_word</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>[</span><span class=n>seed</span><span class=p>],</span> <span class=bp>self</span><span class=o>.</span><span class=n>words</span><span class=p>[</span><span class=n>seed</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>w1</span><span class=p>,</span> <span class=n>w2</span> <span class=o>=</span> <span class=n>seed_word</span><span class=p>,</span> <span class=n>next_word</span>
</span></span><span class=line><span class=cl>        <span class=n>gen_words</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>xrange</span><span class=p>(</span><span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>gen_words</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>w1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>w1</span><span class=p>,</span> <span class=n>w2</span> <span class=o>=</span> <span class=n>w2</span><span class=p>,</span> <span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[(</span><span class=n>w1</span><span class=p>,</span> <span class=n>w2</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=n>gen_words</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>w2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39; &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>gen_words</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=teaching-markov-the-art-of-haikus>Teaching Markov the Art of Haikus</h2><p>Time to make some progress in making some beautifully robotic poetry! The plan for @thehaikuza V0.2 is to create a Markov chain dictionary using song lyrics and create randomized phrases from the resulting keys and values. Although this implementation still doesn&rsquo;t involve a proper grammar model, it&rsquo;s an improvement from the previous method because of its more structured approach. By simply mixing and matching phrases that once made sense before, there&rsquo;s a much higher probability that the resulting phrase will also make some level of sense.</p><p>The success rate should now go from laughable to respectfully laughable! Progress is progress.</p><p><em>Check out the full repo on <a href=https://github.com/justinmklam/project-haikuza>Github</a>!</em></p></div><div class=nav-btn><a href=/>&lt; Recent Posts</a></div><hr><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="justinmklam",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><div style=text-align:center><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>Comments powered by Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>Comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div><script defer id=dsq-count-scr src=//justinmklam.disqus.com/count.js async></script></body><footer><div class=footer-container><hr><p>&copy; 2025 Justin Lam | <a href=/colophon>Colophon</a></p></div></footer></html>